They provide a mutable collection of key-value pairs that lets you efficiently access and mutate values through their corresponding keys:

>>> config = {                                                                                  https://realpython.com/python-dicts/
...     "color": "green",
...     "width": 42,
...     "height": 100,
...     "font": "Courier",
... }

>>> # Access a value through its key
>>> config["color"]
'green'

>>> # Update a value
>>> config["font"] = "Helvetica"
>>> config
{
    'color': 'green',
    'width': 42,
    'height': 100,
    'font': 'Helvetica'
}

__________________________________________________________________________________________________________________________________________________________
 globals() and locals():

The globals() function returns a dictionary containing key-value pairs that map names to objects that live in your current global scope.

>>> globals()
{
    '__name__': '__main__',
    '__doc__': None,
    '__package__': None,
    ...
}
_______________________________________________________________________________________________________________________________________________________________
.__dict__ 

 is a dictionary that maps attribute names to their corresponding values in Python classes and objects. 
_____________________________________________________________________________________________________________________________________________________________
Creating Dictionaries in Python

You can create a dictionary with  => "{ }" & ","   or => dict( )

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Dictionary Literals

You can define a dictionary by enclosing a comma-separated series of key-value pairs in curly braces ({}). To separate the keys from their values, 
you need to use a colon (:). Here’s the syntax for a dictionary literal:

>>> MLB_teams = {
...     "Colorado": "Rockies",
...     "Chicago": "White Sox",
...     "Boston": "Red Sox",
...     "Minnesota": "Twins",
...     "Milwaukee": "Brewers",
...     "Seattle": "Mariners",
... }

********************************************************************************************************************************************
However, you can’t use unhashable objects as keys. If you try to, then you’ll get an error:

Python no permite usar objetos mutables (listas, diccionarios, conjuntos) como claves en diccionarios o elementos de sets, porque no se puede garantizar que su valor hash sea constante

# Lista como clave (error)
try:
    d1 = {[1, 2, 3]: "valor"}
except TypeError as e:
    print(e)  # unhashable type: 'list'

# Tupla en su lugar (funciona)
d2 = {(1, 2, 3): "valor"}
print(d2[(1, 2, 3)])  # valor
********************************************************************************************************************************************
The dict() Constructor

he arguments to dict() can be a series of keyword arguments, another mapping, or an iterable of key-value pairs. Here are the constructor’s signatures:

dict()
dict(**kwargs)
dict(mapping, **kwargs)
dict(iterable, **kwargs)



>>> MLB_teams = dict(
...     Colorado="Rockies",
...     Chicago="White Sox",
...     Boston="Red Sox",
...     Minnesota="Twins",
...     Milwaukee="Brewers",
...     Seattle="Mariners",
... )

>>> MLB_teams
{
    'Colorado': 'Rockies',
    'Chicago': 'White Sox',
    'Boston': 'Red Sox',
    'Minnesota': 'Twins',
    'Milwaukee': 'Brewers',
    'Seattle': 'Mariners'


ALSO YOU CAN create a dictionary from an iterable of key-value pairs.............

>>> MLB_teams = dict(
...     [
...         ("Colorado", "Rockies"),
...         ("Chicago", "White Sox"),
...         ("Boston", "Red Sox"),
...         ("Minnesota", "Twins"),
...         ("Milwaukee", "Brewers"),
...         ("Seattle", "Mariners"),
...     ]
... )

>>> MLB_teams
{
    'Colorado': 'Rockies',
    'Chicago': 'White Sox',
    'Boston': 'Red Sox',
    'Minnesota': 'Twins',
    'Milwaukee': 'Brewers',
    'Seattle': 'Mariners'
}

__________________________________________________________________________________________________________________________________________
Una forma interesante de crear diccionarios a partir de secuencias de valores es combinarlos con la función integrada zip() y luego llamar a dict()

>>> places = [
...     "Colorado",
...     "Chicago",
...     "Boston",
...     "Minnesota",
...     "Milwaukee",
...     "Seattle",
... ]

>>> teams = [
...     "Rockies",
...     "White Sox",
...     "Red Sox",
...     "Twins",
...     "Brewers",
...     "Mariners",
... ]

>>> dict(zip(places, teams))
{
    'Colorado': 'Rockies',
    'Chicago': 'White Sox',
    'Boston': 'Red Sox',
    'Minnesota': 'Twins',
    'Milwaukee': 'Brewers',
    'Seattle': 'Mariners'
}

The zip() function takes one or more iterables as arguments and yields tuples that combine items from each iterable. 
Note that your original data must be stored in ordered sequences for this technique to work correctly because the order is essential.

__________________________________________________________________________________________________________________________________________________________________________
Using the .fromkeys() Class Method

that lets you create new dictionaries from an iterable of keys and a default value.




>>> inventory = dict.fromkeys(["apple", "orange", "banana", "mango"], 0)

>>> inventory
{'apple': 0, 'orange': 0, 'banana': 0, 'mango': 0}


In this example, you create a dictionary to store an inventory of fruits. 
Initially, you have the list of fruits in stock but don’t have the corresponding amounts. So, you use 0 as the default amount in the call to .fromkeys().

*************************************************
.fromkeys(iterable, value=None, /)

The iterable argument provides the keys that you want to include in your dictionary.
Even though the input iterable can have duplicate items, the final dictionary will have unique keys as usual.
**************************************************
_________________________________________________________________________________________________________________________________________________________________________
Accessing Dictionary Values

Once you’ve created a dictionary, you can access its content by keys. 

>>> MLB_teams["Minnesota"]
'Twins'
>>> MLB_teams["Colorado"]
'Rockies'



Now say that you have the following dictionary with a person’s data:
**************************************************************
>>> person = {
...     "first_name": "John",
...     "last_name": "Doe",
...     "age": 35,
...     "spouse": "Jane",
...     "children": ["Ralph", "Betty", "Bob"],
...     "pets": {"dog": "Frieda", "cat": "Sox"},
... }
**************************************************************
>>> person["children"][0]
'Ralph'
>>> person["children"][2]
'Bob'

>>> person["pets"]["dog"]
'Frieda'
>>> person["pets"]["cat"]
'Sox'
______________________________________________________________________________________________________________________________________________________
Populating Dictionaries Incrementally

Python dictionaries are dynamically sized data structures. This means that you can add key-value pairs to your dictionaries dynamically, 
and Python will take care of increasing the dictionary size for you. This characteristic is helpful because it lets you dynamically populate dictionaries with data.

When populating dictionaries, there are three common techniques that you can use. You can:

1" Assign keys manually
2" Add keys in a for loop
3" Build a dictionary with a comprehension

[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
Assigning Keys Manually

Sometimes, you start by creating an empty dictionary with an empty pair of curly braces.

>>> person = {}

>>> person["first_name"] = "John"
>>> person["last_name"] = "Doe"
>>> person["age"] = 35
>>> person["spouse"] = "Jane"
>>> person["children"] = ["Ralph", "Betty", "Bob"]
>>> person["pets"] = {"dog": "Frieda", "cat": "Sox"}

>>> person
{
    'first_name': 'John',
    'last_name': 'Doe',
    'age': 35,
    'spouse': 'Jane',
    'children': ['Ralph', 'Betty', 'Bob'],
    'pets': {'dog': 'Frieda', 'cat': 'Sox'}
}
[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]][[[[
Adding Keys in a for Loop

situations where a for loop is a good approach for populating an empty dictionary with new data. 

>>> squares = {}

>>> for integer in range(1, 10):
...     squares[integer] = integer**2
...

>>> squares
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
Building Dictionaries With Comprehensions

is another great tool for creating and populating dictionaries with concise syntax. 

>>> squares = {integer: integer**2 for integer in range(1, 10)}
>>> squares
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[

Exploring the dict Class Methods

Getting Individual Keys: .get(key, default=None)

El método .get() proporciona una forma cómoda de recuperar el valor asociado a una clave sin comprobar previamente si la clave existe.


>>> inventory = {"apple": 100, "orange": 80, "banana": 100}

>>> inventory.get("apple")
100
>>> print(inventory.get("mango"))
None
_______________________________________________________________________________________________________________________
Retrieving All the Values: .values()

The .values() method returns a dictionary view object, which provides a dynamic view of the values in a dictionary:


>>> inventory = {"apple": 100, "orange": 80, "banana": 100}

>>> inventory.values()
dict_values([100, 80, 100])
_______________________________________________________________________________________________________________________
Accessing All the Keys: .keys()

The .keys() method returns a dictionary view object with a dynamic view of the keys in the target dictionary:

>>> inventory = {"apple": 100, "orange": 80, "banana": 100}

>>> inventory.keys()
dict_keys(['apple', 'orange', 'banana'])
________________________________________________________________________________________________________________________
Getting All the Items or Key-Value Pairs: .items()

The .items() method returns a dictionary view containing tuples of keys and values.

>>> inventory = {"apple": 100, "orange": 80, "banana": 100}

>>> inventory.items()
dict_items([('apple', 100), ('orange', 80), ('banana', 100)])
___________________________________________________________________________________________________________________________________________________________
Adding Key-Value Pairs and Updating Dictionaries

.setdefault() and .update() 

###########################################################################################################################################
Setting One Key: .setdefault(key, default=None)

 Si la clave está en el diccionario, el método devuelve el valor asociado. Si la clave no está en el diccionario, se inserta con el valor 
predeterminado como valor asociado. A continuación, devuelve el valor predeterminado:


>>> inventory = {"apple": 100, "orange": 80}

>>> inventory.setdefault("apple")
100
>>> print(inventory.setdefault("mango"))
None
>>> inventory
{'apple': 100, 'orange': 80, 'mango': None}
>>> inventory.setdefault("banana", 0)
0
>>> inventory
{'apple': 100, 'orange': 80, 'mango': None, 'banana': 0}
###########################################################################################################################################
Updating a Dictionary: .update([other])

El método .update() fusiona un diccionario con otro diccionario o con un iterable de pares clave-valor.


>>> config = {
...     "color": "green",
...     "width": 42,
...     "height": 100,
...     "font": "Courier",
... }

>>> user_config = {
...     "path": "/home",
...     "color": "red",
...     "font": "Arial",
...     "position": (200, 100),
... }

>>> config.update(user_config)

>>> config
{
    'color': 'red',
    'width': 42,
    'height': 100,
    'font': 'Arial',
    'path': '/home',
    'position': (200, 100)
}
_____________________________________________________________________________________________________________________________________________________________
Removing Data From Dictionaries


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Removing Keys: .pop(key[, default])

El método .pop() elimina pares clave-valor por clave. Si la clave existe, el método devuelve su valor asociado.

>>> inventory = {"apple": 100, "orange": 80, "banana": 100}

>>> inventory.pop("apple")
100
>>> inventory
{'orange': 80, 'banana': 100}

>>> inventory.pop("mango")
Traceback (most recent call last):
    ...
KeyError: 'mango'

>>> inventory.pop("mango", 0)
0
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Deleting Items: .popitem()

El método .popitem() elimina un par clave-valor de un diccionario. 


>>> inventory = {"apple": 100, "orange": 80, "banana": 100}

>>> inventory.popitem()
('banana', 100)
>>> inventory
{'apple': 100, 'orange': 80}

>>> inventory.popitem()
('orange', 80)
>>> inventory
{'apple': 100}

>>> inventory.popitem()
('apple', 100)
>>> inventory
{}
;;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Clearing Dictionaries: .clear()

The .clear() method removes all the items from a dictionary:


>>> inventory = {"apple": 100, "orange": 80, "banana": 100}
>>> inventory
{'apple': 100, 'orange': 80, 'banana': 100}
>>> inventory.clear()
>>> inventory
{}
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Using Operators With Dictionaries

Los operadores de pertenencia in y not in te permiten determinar si una clave, un valor o un elemento determinado se encuentra en un diccionario, 
dependiendo del iterable de destino que utilices.

>>> MLB_teams = {
...     "Colorado": "Rockies",
...     "Chicago": "White Sox",
...     "Boston": "Red Sox",
...     "Minnesota": "Twins",
...     "Milwaukee": "Brewers",
...     "Seattle": "Mariners",
... }

>>> "Milwaukee" in MLB_teams
True
>>> "Indianapolis" in MLB_teams
False
>>> "Indianapolis" not in MLB_teams
True

>>> "Milwaukee" in MLB_teams.keys()
True
>>> "Indianapolis" in MLB_teams.keys()
False
>>> "Indianapolis" not in MLB_teams.keys()
True
______________________________________________________________________________________________________________________________
Equality and Inequality: == and !=

>>> [1, 2, 3] == [3, 2, 1]
False
>>> {1: 1, 2: 2, 3: 3} == {3: 3, 2: 2, 1: 1}
True

>>> [1, 2, 3] != [3, 2, 1]
True
>>> {1: 1, 2: 2, 3: 3} != {3: 3, 2: 2, 1: 1}
False
______________________________________________________________________________________________________________________________
Union and Augmented Union: | and |=

El operador de unión (|) crea un nuevo diccionario fusionando las claves y los valores de dos diccionarios iniciales. 

>>> default_config = {
...     "color": "green",
...     "width": 42,
...     "height": 100,
...     "font": "Courier",
... }

>>> user_config = {
...     "path": "/home",
...     "color": "red",
...     "font": "Arial",
...     "position": (200, 100),
... }

>>> config = default_config | user_config
>>> config
{
    'color': 'red',
    'width': 42,
    'height': 100,
    'font': 'Arial',
    'path': '/home',
    'position': (200, 100)
}


don’t create a new dictionary for the final configuration. Instead, 
you update the existing dictionary with the content of user_config using the augmented union operator.
____________________________________________________________________________________________________________________________
Use Built-in Functions With Dictionaries

******************************************************************************************************
all()	Returns True if all the items in an iterable are truthy and False otherwise
any()	Returns True if at least one element in the iterable is truthy and False otherwise.



>>> inventory = {"apple": 100, "orange": 80, "banana": 100, "mango": 200}
>>> all(inventory.values())
True
>>> # Update the stock
>>> inventory["mango"] = 0
>>> all(inventory.values())
False
*****************************************************************************************************
len()	Returns an integer representing the number of items in the input object.

>>> MLB_teams = {
...     "Colorado": "Rockies",
...     "Chicago": "White Sox",
...     "Boston": "Red Sox",
...     "Minnesota": "Twins",
...     "Milwaukee": "Brewers",
...     "Seattle": "Mariners",
... }

>>> len(MLB_teams)
6
*****************************************************************************************************
max()	Returns the largest value in an iterable or series of arguments.

>>> computer_parts = {
...     "CPU": 299.99,
...     "Motherboard": 149.99,
...     "RAM": 89.99,
...     "GPU": 499.99,
...     "SSD": 129.99,
...     "Power Supply": 79.99,
...     "Case": 99.99,
...     "Cooling System": 59.99,
... }

>>> min(computer_parts.values())
59.99
>>> max(computer_parts.values())
499.99
*****************************************************************************************************
min()	Returns the smallest value in an iterable or series of arguments.

*****************************************************************************************************
sorted()	Returns a new sorted list of the elements in the iterable.

>>> students = {
...     "Alice": 89.5,
...     "Bob": 76.0,
...     "Charlie": 92.3,
...     "Diana": 84.7,
...     "Ethan": 88.9,
...     "Fiona": 95.6,
...     "George": 73.4,
...     "Hannah": 81.2,
... }

>>> dict(sorted(students.items(), key=lambda item: item[1]))
{
    'George': 73.4,
    'Bob': 76.0,
    'Hannah': 81.2,
    'Diana': 84.7,
    'Ethan': 88.9,
    'Alice': 89.5,
    'Charlie': 92.3,
    'Fiona': 95.6
}

>>> dict(sorted(students.items(), key=lambda item: item[1], reverse=True))
{
    'Fiona': 95.6,
    'Charlie': 92.3,
    'Alice': 89.5,
    'Ethan': 88.9,
    'Diana': 84.7,
    'Hannah': 81.2,
    'Bob': 76.0,
    'George': 73.4
}

>>> sorted(students)
['Alice', 'Bob', 'Charlie', 'Diana', 'Ethan', 'Fiona', 'George', 'Hannah']

>>> sorted(students.values())
[73.4, 76.0, 81.2, 84.7, 88.9, 89.5, 92.3, 95.6]
*****************************************************************************************************
sum()	Returns the sum of a start value and the values in the input iterable from left to right.

>>> daily_sales = {
...     "Monday": 1500,
...     "Tuesday": 1750,
...     "Wednesday": 1600,
...     "Thursday": 1800,
...     "Friday": 2000,
...     "Saturday": 2200,
...     "Sunday": 2100,
... }

>>> sum(daily_sales.values()) / len(daily_sales)
1850.0
In this example, you use the sum() function to calculate the total sales. To do this, you use the .values() method. 
Then, you compute the average with the help of len().
*****************************************************************************************************
_____________________________________________________________________________________________________________________________
Iterating Over Dictionaries

allowing you to iterate over their keys, values, and items.

***************************************************************************************************
Traversing Dictionaries by Keys

Hay dos formas diferentes de iterar sobre las claves de un diccionario. Puedes usar el diccionario directamente 
o utilizar el método .keys().

>>> students = {
...     "Alice": 89.5,
...     "Bob": 76.0,
...     "Charlie": 92.3,
...     "Diana": 84.7,
...     "Ethan": 88.9,
...     "Fiona": 95.6,
...     "George": 73.4,
...     "Hannah": 81.2,
... }

>>> for student in students:
...     print(student)
...
Alice
Bob
Charlie
Diana
Ethan
Fiona
George
Hannah

>>> for student in students.keys():
...     print(student)
...
Alice
Bob
Charlie
Diana
Ethan
Fiona
George
Hannah
*****************************************************************************************************
Iterating Over Dictionary Values

Cuando se trata de iterar a través de los valores de un diccionario, puedes utilizar el método .values() para alimentar el bucle.

>>> MLB_teams = {
...     "Colorado": "Rockies",
...     "Chicago": "White Sox",
...     "Boston": "Red Sox",
...     "Minnesota": "Twins",
...     "Milwaukee": "Brewers",
...     "Seattle": "Mariners",
... }

>>> for team in MLB_teams.values():
...     print(team)
...
Rockies
White Sox
Red Sox
Twins
Brewers
Mariners


En este ejemplo, se itera sobre los equipos registrados de la MLB uno por uno. Ten en cuenta que cuando utilizas el método 
.values(), no puedes acceder a las claves del diccionario.
*******************************************************************************************************
Looping Through Dictionary Items

>>> for place, team in MLB_teams.items():
...     print(place, "->", team)
...
Colorado -> Rockies
Chicago -> White Sox
Boston -> Red Sox
Minnesota -> Twins
Milwaukee -> Brewers
Seattle -> Mariners
**********************************************************************************************************
______________________________________________________________________________________________________________________________
Exploring Existing Dictionary-Like Classes



*************************************************************************************************
OrderedDict	    A dictionary subclass specially designed to remember the order of items, which is defined by the insertion order of keys.


OrderedDict ya no es tan útil porque, desde Python 3.6, los diccionarios mantienen sus elementos en el
mismo orden de inserción. Sin embargo, es posible que encuentres algunas diferencias interesantes entre dict 
y OrderedDict que te ayuden a decidir qué diccionario se adapta mejor a tus necesidades.

La clase Counter proporciona una herramienta eficaz y práctica para contar objetos:
**************************************************************************************************
Counter	A dictionary subclass specially designed to provide efficient counting capabilities out of the box.



*************************************************************************************************
defaultdict	A dictionary subclass specially designed to handle missing keys in dictionaries.


automatically creates a new key and generates a default value for it when you try to access or modify a missing key.


>>> from collections import defaultdict

>>> departments = defaultdict(list)

>>> for department, employee in employees:
...     departments[department].append(employee)
...

>>> departments
defaultdict(<class 'list'>,
    {
        'Sales': ['John', 'Martin'],
        'Accounting': ['Kate'],
        'Marketing': ['Elizabeth', 'Linda']
     }
)
*************************************************************************************************
_______________________________________________________________________________________________________________________________
Creating Custom Dictionary-Like Classes

También puedes crear clases personalizadas similares a diccionarios en Python. Para ello, puedes heredar de una de las siguientes clases:

************************************
La clase dict incorporada
La clase collections.UserDict
***********************************
El primer enfoque puede dar lugar a algunos problemas, pero puede funcionar en situaciones en las que se desea añadir 
funcionalidad que no implique cambiar la funcionalidad básica de dict. El segundo enfoque es más fiable y seguro, y se puede 
utilizar en la mayoría de los casos.


class SortableDict(dict):
    def sort_by_keys(self, reverse=False):
        sorted_items = sorted(
            self.items(),
            key=lambda item: item[0],
            reverse=reverse
        )
        self.clear()
        self.update(sorted_items)

    def sort_by_values(self, reverse=False):
        sorted_items = sorted(
            self.items(),
            key=lambda item: item[1],
            reverse=reverse
        )
        self.clear()
        self.update(sorted_items)


En este ejemplo, se hereda de la clase dict incorporada. Además de la funcionalidad predeterminada de la clase, 
se añaden dos nuevos métodos para ordenar el diccionario por claves y valores en el lugar, lo que significa que estos
métodos no crean un nuevo objeto diccionario, sino que modifican el actual.





Here’s how your class works in practice:

>>> from sorted_dict import SortableDict

>>> students = SortableDict(
...     {
...         "Alice": 89.5,
...         "Bob": 76.0,
...         "Charlie": 92.3,
...         "Diana": 84.7,
...         "Ethan": 88.9,
...         "Fiona": 95.6,
...         "George": 73.4,
...         "Hannah": 81.2,
...     }
... )

>>> id(students)
4350960304

>>> students.sort_by_values(reverse=True)
>>> students
{
    'Fiona': 95.6,
    'Charlie': 92.3,
    'Alice': 89.5,
    'Ethan': 88.9,
    'Diana': 84.7,
    'Hannah': 81.2,
    'Bob': 76.0,
    'George': 73.4
}

>>> students.sort_by_keys()
>>> students
{
    'Alice': 89.5,
    'Bob': 76.0,
    'Charlie': 92.3,
    'Diana': 84.7,
    'Ethan': 88.9,
    'Fiona': 95.6,
    'George': 73.4,
    'Hannah': 81.2
}

>>> id(students)
4350960304


En este ejemplo, se crea una instancia de SortableDict. A continuación, se llama al método .sort_by_values() 
para ordenar el diccionario por calificaciones en orden inverso. Después, se llama al método .sort_by_keys() 
para ordenar el diccionario alfabéticamente por nombres de estudiantes, que son las claves.

Las líneas resaltadas muestran que la identidad de la instancia permanece sin cambios durante el proceso de 
ordenación. Esto confirma que tanto el método .sort_by_keys() como el método .sort_by_values() modifican el 
diccionario en el lugar en lugar de crear nuevos diccionarios.
______________________________________________________________________________________________________
